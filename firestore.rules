rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ===== HELPER FUNCTIONS =====
    function signedIn() {
      return request.auth != null;
    }

    function isAuth(uid) {
      return request.auth != null && request.auth.uid == uid;
    }

    // Walk helpers
    function isHostOfWalk(walk) {
      return signedIn() && walk.hostUid == request.auth.uid;
    }

    // Treat missing visibility as OPEN (backwards compatible)
    function isOpenWalk(walk) {
      return walk.visibility != 'private';
    }

    // Allowed = user has redeemed invite (written by Cloud Function using Admin SDK)
    function isAllowedViewer(walkId) {
      return signedIn()
        && exists(/databases/$(database)/documents/walks/$(walkId)/allowed/$(request.auth.uid));
    }

    // Participant = host OR accepted/joined
    // NOTE: allowed viewers are NOT participants by default (no chat access)
    function isParticipant(walkId) {
      let walk = get(/databases/$(database)/documents/walks/$(walkId)).data;
      return signedIn()
        && (
          walk.hostUid == request.auth.uid ||
          (walk.joinedUids != null && request.auth.uid in walk.joinedUids)
        );
    }

    // Rate limiting helper (simple check)
    function isRateLimited() {
      return request.time < resource.data.rateLimitUntil;
    }

    // ===== USERS COLLECTION (NEW) =====
    match /users/{userId} {
      allow get: if signedIn();
      
      allow list: if false; // Never allow listing all users

      allow create: if isAuth(userId)
        && request.resource.data.keys().hasOnly([
          'uid', 'email', 'displayName', 'photoURL', 
          'bio', 'createdAt', 'lastUpdated'
        ])
        && request.resource.data.uid == userId
        && request.resource.data.email is string
        && request.resource.data.displayName is string
        && request.resource.data.createdAt is timestamp;

      allow update: if isAuth(userId)
        && request.resource.data.uid == resource.data.uid
        && request.resource.data.email == resource.data.email
        && request.resource.data.createdAt == resource.data.createdAt;

      allow delete: if false; // Never allow user self-deletion (use admin)

      // User stats subcollection
      match /stats/{document=**} {
        allow read: if signedIn();
        allow create, update: if isAuth(userId);
        allow delete: if false;
      }

      // User walks history
      match /walks/{walkId} {
        allow read: if isAuth(userId);
        allow create, update: if isAuth(userId)
          && request.resource.data.userId == userId
          && request.resource.data.joinedAt is timestamp;
        allow delete: if isAuth(userId);
      }

      // User badges
      match /badges/{badgeId} {
        allow read: if signedIn();
        allow write: if false; // Server-side only
      }

      // FCM tokens for notifications
      match /fcmTokens/{tokenId} {
        allow read: if isAuth(userId);
        allow write: if isAuth(userId);
      }
    }

    // ===== REVIEWS COLLECTION =====
    match /reviews/{reviewId} {
      allow read: if true; // Anyone can read reviews

      allow create: if request.auth != null
        && request.resource.data.keys().hasOnly(['walkId','userId','userName','userProfileUrl','rating','reviewText','createdAt','helpfulCount','helpfulBy'])
        && request.resource.data.walkId is string
        && request.resource.data.userId == request.auth.uid
        && request.resource.data.userName is string
        && (request.resource.data.userProfileUrl == null || request.resource.data.userProfileUrl is string)
        && request.resource.data.rating is number && request.resource.data.rating >= 1 && request.resource.data.rating <= 5
        && request.resource.data.reviewText is string && request.resource.data.reviewText.size() <= 500
        && request.resource.data.createdAt is timestamp
        && request.resource.data.helpfulCount is number && request.resource.data.helpfulCount == 0
        && request.resource.data.helpfulBy is list && request.resource.data.helpfulBy.size() == 0;

      allow update: if request.auth != null && (
        (
          resource.data.userId == request.auth.uid
          && request.resource.data.diff(resource.data).changedKeys().hasOnly(['rating','reviewText'])
          && request.resource.data.rating is number && request.resource.data.rating >= 1 && request.resource.data.rating <= 5
          && request.resource.data.reviewText is string && request.resource.data.reviewText.size() <= 500
        ) ||
        (
          request.resource.data.diff(resource.data).changedKeys().hasOnly(['helpfulBy','helpfulCount'])
          && request.resource.data.helpfulBy is list
          && request.resource.data.helpfulBy.size() == resource.data.helpfulBy.size() + 1
          && !(request.auth.uid in resource.data.helpfulBy)
          && (request.auth.uid in request.resource.data.helpfulBy)
          && request.resource.data.helpfulCount == resource.data.helpfulCount + 1
        )
      );

      allow delete: if request.auth != null && resource.data.userId == request.auth.uid;
    }

    // ===== WALKS COLLECTION =====
    match /walks/{walkId} {

      // READ walks: open (or missing visibility): any signed-in user; private: host OR allowed viewer
      allow get, list: if signedIn()
        && (
          isOpenWalk(resource.data) ||
          isHostOfWalk(resource.data) ||
          isAllowedViewer(walkId)
        );

      // CREATE: only if hostUid == current user (with validation)
      allow create: if signedIn()
        && request.resource.data.hostUid == request.auth.uid
        && request.resource.data.keys().hasAny(['title', 'dateTime', 'distanceKm'])
        && request.resource.data.title is string
        && request.resource.data.dateTime is timestamp
        && request.resource.data.distanceKm is number;

      // UPDATE: host can change anything; non-hosts can modify join metadata only
      allow update: if signedIn() && (
        resource.data.hostUid == request.auth.uid
        || (
          request.resource.data.diff(resource.data).changedKeys().hasOnly(
            ['joinedUids','joinedUserUids','joinedUserPhotoUrls','joinedCount']
          )
          && request.resource.data.joinedUids is list
          && request.resource.data.joinedUserUids is list
          && (!request.resource.data.keys().hasAny(['joinedUserPhotoUrls'])
              || request.resource.data.joinedUserPhotoUrls is list)
          && request.resource.data.joinedCount is number
        )
      );

      // DELETE: host only
      allow delete: if signedIn()
        && resource.data.hostUid == request.auth.uid;

      // Subcollection: allowed viewers (invite redeemed)
      match /allowed/{uid} {
        allow get: if signedIn()
          && (get(/databases/$(database)/documents/walks/$(walkId)).data.hostUid == request.auth.uid
              || request.auth.uid == uid);

        allow list: if signedIn()
          && get(/databases/$(database)/documents/walks/$(walkId)).data.hostUid == request.auth.uid;

        allow create, update, delete: if signedIn()
          && get(/databases/$(database)/documents/walks/$(walkId)).data.hostUid == request.auth.uid;
      }

      // Subcollection: join requests
      match /joinRequests/{uid} {
        allow create, get: if signedIn() && request.auth.uid == uid;

        allow get, list, update, delete: if signedIn()
          && get(/databases/$(database)/documents/walks/$(walkId)).data.hostUid == request.auth.uid;
      }
    }

    // ===== CHAT RULES (PARTICIPANT-ONLY) =====
    match /walk_chats/{walkId} {
      allow read: if isParticipant(walkId);

      allow create, update: if isParticipant(walkId)
        && request.resource.data.walkId == walkId;

      allow delete: if false;

      match /messages/{messageId} {
        allow read: if isParticipant(walkId);

        allow create: if isParticipant(walkId)
          && request.resource.data.senderId == request.auth.uid
          && request.resource.data.text is string
          && request.resource.data.text.size() > 0
          && request.resource.data.text.size() <= 1000  // Max message length
          && request.resource.data.sentAt is timestamp;

        allow update, delete: if false;
      }
    }

    // ===== FRIEND REQUESTS (NEW) =====
    match /friend_requests/{userId} {
      // Users can only access their own friend requests
      allow get, list: if isAuth(userId);

      match /received/{requestId} {
        allow read, create, delete: if isAuth(userId);
      }

      match /sent/{requestId} {
        allow read, create, delete: if isAuth(userId);
      }
    }

    // ===== FRIENDS LIST (NEW) =====
    match /friends/{userId} {
      allow get: if signedIn();

      match /friendsList/{friendId} {
        allow read: if signedIn();
        allow write: if isAuth(userId);
      }
    }

    // ===== CATCH-ALL: DENY EVERYTHING ELSE =====
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
