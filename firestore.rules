rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ===== HELPER FUNCTIONS =====
    function signedIn() {
      return request.auth != null;
    }

    function isAuth(uid) {
      return request.auth != null && request.auth.uid == uid;
    }

    // Walk helpers
    function isHostOfWalk(walk) {
      return signedIn() && walk.hostUid == request.auth.uid;
    }

    // Treat missing visibility as OPEN (backwards compatible)
    function isOpenWalk(walk) {
      return walk.visibility != 'private';
    }

    // Allowed = user has redeemed invite (written by Cloud Function using Admin SDK)
    function isAllowedViewer(walkId) {
      return signedIn()
        && exists(/databases/$(database)/documents/walks/$(walkId)/allowed/$(request.auth.uid));
    }

    // Participant = host OR accepted/joined
    // NOTE: allowed viewers are NOT participants by default (no chat access)
    function isParticipant(walkId) {
      let walk = get(/databases/$(database)/documents/walks/$(walkId)).data;
      return signedIn()
        && (
          walk.hostUid == request.auth.uid ||
          (walk.joinedUids != null && request.auth.uid in walk.joinedUids)
        );
    }

    function isFriendOf(uid) {
      return signedIn()
        && (
          exists(/databases/$(database)/documents/friends/$(uid)/friendsList/$(request.auth.uid))
          || exists(/databases/$(database)/documents/friends/$(request.auth.uid)/friendsList/$(uid))
        );
    }

    function _threadDataContainsUser(data) {
      return data != null
        && (
          (data.participants != null && request.auth.uid in data.participants)
          || (data.memberIds != null && request.auth.uid in data.memberIds)
        );
    }

    function dmThreadHasParticipant(threadId) {
      return signedIn()
        && _threadDataContainsUser(
          get(/databases/$(database)/documents/dm_threads/$(threadId)).data,
        );
    }

    function dmResourceHasParticipant() {
      return signedIn() && _threadDataContainsUser(resource.data);
    }

    // ===== USERS COLLECTION (NEW) =====
    match /users/{userId} {
      allow get: if signedIn();

      // Allow small, filtered queries (friend search, whereIn batches) but
      // continue blocking blanket reads of the entire collection.
      allow list: if signedIn()
        && (request.query.limit == null || request.query.limit <= 50);

      allow create: if isAuth(userId)
        && request.resource.data.keys().hasAny(['uid', 'email', 'displayName', 'createdAt'])
        && request.resource.data.uid == userId
        && request.resource.data.email is string
        && request.resource.data.displayName is string
        && request.resource.data.createdAt is timestamp;

      allow update: if isAuth(userId)
        && request.resource.data.uid == resource.data.uid
        && request.resource.data.email == resource.data.email
        && request.resource.data.createdAt == resource.data.createdAt;

      allow delete: if false; // Never allow user self-deletion (use admin)

      // User stats subcollection
      match /stats/{document=**} {
        allow read: if signedIn();
        allow create, update: if isAuth(userId);
        allow delete: if false;
      }

      // User walks history
      match /walks/{walkId} {
        allow read: if isAuth(userId);
        allow create, update: if isAuth(userId)
          && request.resource.data.userId == userId
          && request.resource.data.joinedAt is timestamp;
        allow delete: if isAuth(userId);
      }

      // User badges
      match /badges/{badgeId} {
        allow read: if isAuth(userId);
        allow create, update: if isAuth(userId)
          && request.resource.data.keys().hasOnly(['title','description','progress','target','achieved','earnedAt','metric','updatedAt'])
          && request.resource.data.title is string
          && request.resource.data.description is string
          && request.resource.data.progress is number
          && request.resource.data.target is number
          && request.resource.data.achieved is bool
          && (request.resource.data.earnedAt == null || request.resource.data.earnedAt is timestamp)
          && request.resource.data.metric is string
          && request.resource.data.updatedAt is timestamp;
        allow delete: if false;
      }

      // FCM tokens for notifications
      match /fcmTokens/{tokenId} {
        allow read: if isAuth(userId);
        allow write: if isAuth(userId);
      }
    }

    // ===== REVIEWS COLLECTION =====
    match /reviews/{reviewId} {
      allow read: if true; // Anyone can read reviews

      allow create: if request.auth != null
        && request.resource.data.keys().hasOnly(['walkId','userId','userName','userProfileUrl','rating','reviewText','createdAt','helpfulCount','helpfulBy'])
        && request.resource.data.walkId is string
        && request.resource.data.userId == request.auth.uid
        && request.resource.data.userName is string
        && (request.resource.data.userProfileUrl == null || request.resource.data.userProfileUrl is string)
        && request.resource.data.rating is number && request.resource.data.rating >= 1 && request.resource.data.rating <= 5
        && request.resource.data.reviewText is string && request.resource.data.reviewText.size() <= 500
        && request.resource.data.createdAt is timestamp
        && request.resource.data.helpfulCount is number && request.resource.data.helpfulCount == 0
        && request.resource.data.helpfulBy is list && request.resource.data.helpfulBy.size() == 0;

      allow update: if request.auth != null && (
        (
          resource.data.userId == request.auth.uid
          && request.resource.data.diff(resource.data).changedKeys().hasOnly(['rating','reviewText'])
          && request.resource.data.rating is number && request.resource.data.rating >= 1 && request.resource.data.rating <= 5
          && request.resource.data.reviewText is string && request.resource.data.reviewText.size() <= 500
        ) ||
        (
          request.resource.data.diff(resource.data).changedKeys().hasOnly(['helpfulBy','helpfulCount'])
          && request.resource.data.helpfulBy is list
          && request.resource.data.helpfulBy.size() == resource.data.helpfulBy.size() + 1
          && !(request.auth.uid in resource.data.helpfulBy)
          && (request.auth.uid in request.resource.data.helpfulBy)
          && request.resource.data.helpfulCount == resource.data.helpfulCount + 1
        )
      );

      allow delete: if request.auth != null && resource.data.userId == request.auth.uid;
    }

    // ===== WALKS COLLECTION =====
    match /walks/{walkId} {

      // READ walks: open (or missing visibility): any signed-in user; private: host OR allowed viewer
      allow get, list: if signedIn()
        && (
          isOpenWalk(resource.data) ||
          isHostOfWalk(resource.data) ||
          isAllowedViewer(walkId)
        );

      // CREATE: only if hostUid == current user (simplified - no field validation)
      allow create: if signedIn()
        && request.resource.data.hostUid == request.auth.uid;

      // UPDATE: host can change anything; non-hosts can modify join metadata only
      allow update: if signedIn() && (
        resource.data.hostUid == request.auth.uid
        || (
          request.resource.data.diff(resource.data).changedKeys().hasOnly(
            ['joinedUids','joinedUserUids','joinedUserPhotoUrls','joinedCount','participantStates']
          )
          && request.resource.data.joinedUids is list
          && request.resource.data.joinedUserUids is list
          && (!request.resource.data.keys().hasAny(['joinedUserPhotoUrls'])
              || request.resource.data.joinedUserPhotoUrls is list)
          && request.resource.data.joinedCount is number
          && (!request.resource.data.keys().hasAny(['participantStates'])
              || request.resource.data.participantStates is map)
        )
      );

      // DELETE: host only
      allow delete: if signedIn()
        && resource.data.hostUid == request.auth.uid;

      // Subcollection: allowed viewers (invite redeemed)
      match /allowed/{uid} {
        allow get: if signedIn()
          && (get(/databases/$(database)/documents/walks/$(walkId)).data.hostUid == request.auth.uid
              || request.auth.uid == uid);

        allow list: if signedIn()
          && get(/databases/$(database)/documents/walks/$(walkId)).data.hostUid == request.auth.uid;

        allow create, update, delete: if signedIn()
          && get(/databases/$(database)/documents/walks/$(walkId)).data.hostUid == request.auth.uid;
      }

      // Subcollection: join requests
      match /joinRequests/{uid} {
        allow create, get: if signedIn() && request.auth.uid == uid;

        allow get, list, update, delete: if signedIn()
          && get(/databases/$(database)/documents/walks/$(walkId)).data.hostUid == request.auth.uid;
      }
    }

    // ===== CHAT RULES (PARTICIPANT-ONLY) =====
    match /walk_chats/{walkId} {
      allow read: if isParticipant(walkId);

      allow create, update: if isParticipant(walkId)
        && request.resource.data.walkId == walkId;

      allow delete: if false;

      match /messages/{messageId} {
        allow read: if isParticipant(walkId);

        allow create: if isParticipant(walkId)
          && request.resource.data.senderId == request.auth.uid
          && request.resource.data.text is string
          && request.resource.data.text.size() > 0
          && request.resource.data.text.size() <= 1000  // Max message length
          && request.resource.data.sentAt != null;

        allow update, delete: if false;
      }
    }


    // ===== FRIEND REQUESTS (NEW) =====
    match /friend_requests/{userId} {
      // Users can only access their own friend requests
      allow get, list: if isAuth(userId);

      match /received/{requestId} {
        allow read, delete: if isAuth(userId);
        allow create: if signedIn()
          && request.resource.data.fromUserId == request.auth.uid
          && request.resource.data.toUserId == userId
          && request.resource.data.status == 'pending';
      }

      match /sent/{requestId} {
        allow read: if isAuth(userId)
          || (request.auth != null && resource.data.toUserId == request.auth.uid);
        allow delete: if isAuth(userId)
          || (request.auth != null && resource.data.toUserId == request.auth.uid);
        allow create: if isAuth(userId)
          && request.resource.data.fromUserId == userId
          && request.resource.data.status == 'pending';
      }
    }

    // ===== FRIENDS LIST (NEW) =====
    match /friends/{userId} {
      allow get: if isAuth(userId);

      match /friendsList/{friendId} {
        allow read: if isAuth(userId) || isAuth(friendId);
        allow write: if (
            isAuth(userId)
            && request.auth.uid == userId
          ) || (
            request.auth != null
            && request.auth.uid == friendId
            && request.resource.data.friendId == friendId
            && request.resource.data.keys().hasOnly(['friendId','since'])
          );
        allow delete: if isAuth(userId)
          || (request.auth != null && request.auth.uid == friendId);
      }
    }

    // ===== FRIEND PROFILES (READ-ONLY SNAPSHOTS FOR FRIEND VIEW) =====
    match /friend_profiles/{userId} {
      allow get: if isAuth(userId) || isFriendOf(userId);
      allow list: if (isAuth(userId) || isFriendOf(userId))
        && request.query != null
        && request.query.limit != null
        && request.query.limit <= 50;
      allow create, update, delete: if false; // Managed by backend only

      match /walk_summaries/{walkId} {
        allow get: if isAuth(userId) || isFriendOf(userId);
        allow list: if (isAuth(userId) || isFriendOf(userId))
          && request.query != null
          && request.query.limit != null
          && request.query.limit <= 50;
        allow create, update, delete: if false;
      }
    }

    // ===== DIRECT MESSAGE THREADS =====
    match /dm_threads/{threadId} {
      allow get: if dmResourceHasParticipant();
      allow list: if false;

      allow create: if signedIn()
        && request.resource.data.participants is list
        && request.resource.data.participants.size() == 2
        && request.resource.data.participants[0] is string
        && request.resource.data.participants[1] is string
        && request.resource.data.participants[0] != request.resource.data.participants[1]
        && request.auth.uid in request.resource.data.participants;

      allow update: if dmResourceHasParticipant();
      allow delete: if false;

      match /messages/{messageId} {
        allow get, list: if dmThreadHasParticipant(threadId);

        allow create: if dmThreadHasParticipant(threadId)
          && request.resource.data.senderId == request.auth.uid
          && request.resource.data.type is string
          && request.resource.data.createdAt != null
          && (
            (
              request.resource.data.type == 'text'
              && request.resource.data.text is string
              && request.resource.data.text.size() > 0
              && request.resource.data.text.size() <= 2000
            )
            || (
              request.resource.data.type == 'image'
              && request.resource.data.mediaUrl is string
            )
          );

        allow update, delete: if false;
      }
    }

    // ===== BADGE LEADERBOARDS (READ-ONLY) =====
    match /leaderboards/{leaderboardId} {
      // Global and per-badge leaderboards are read-only for clients
      allow get: if signedIn();
      allow list: if false;
      allow create, update, delete: if false; // Managed by backend only

      match /rankings/{userId} {
        allow get, list: if signedIn();
        allow create, update, delete: if false; // Managed by backend only
      }
    }

    // ===== CATCH-ALL: DENY EVERYTHING ELSE =====
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
